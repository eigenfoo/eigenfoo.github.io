<!doctype html><html lang=en-us><head><meta http-equiv=x-clacks-overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://www.georgeho.org/favicon.ico><title>What I Wish Someone Had Told Me About Tensor Computation Libraries | George Ho</title><meta name=title content="What I Wish Someone Had Told Me About Tensor Computation Libraries"><meta name=description content="I get confused with tensor computation libraries (or computational graph libraries, or symbolic algebra libraries, or whatever they&rsquo;re marketing themselves as these days).
I was first introduced to PyTorch and TensorFlow and, having no other reference, thought they were prototypical examples of tensor computation libraries. Then I learnt about Theano &mdash; an older and less popular project, but different from PyTorch and TensorFlow and better in some meaningful ways. This was followed by JAX, which seemed to be basically NumPy with more bells and whistles (although I couldn&rsquo;t articulate what exactly they were)."><meta name=keywords content="open-source,machine-learning,deep-learning,"><meta property="og:title" content="What I Wish Someone Had Told Me About Tensor Computation Libraries"><meta property="og:description" content="I get confused with tensor computation libraries (or computational graph libraries, or symbolic algebra libraries, or whatever they&rsquo;re marketing themselves as these days).
I was first introduced to PyTorch and TensorFlow and, having no other reference, thought they were prototypical examples of tensor computation libraries. Then I learnt about Theano &mdash; an older and less popular project, but different from PyTorch and TensorFlow and better in some meaningful ways. This was followed by JAX, which seemed to be basically NumPy with more bells and whistles (although I couldn&rsquo;t articulate what exactly they were)."><meta property="og:type" content="article"><meta property="og:url" content="https://www.georgeho.org/tensor-computation-libraries/"><meta property="og:image" content="https://www.georgeho.org/assets/images/asterism.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2020-12-15T00:00:00+00:00"><meta property="article:modified_time" content="2020-12-15T00:00:00+00:00"><meta property="og:site_name" content="⁂ George Ho"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.georgeho.org/assets/images/asterism.png"><meta name=twitter:title content="What I Wish Someone Had Told Me About Tensor Computation Libraries"><meta name=twitter:description content="I get confused with tensor computation libraries (or computational graph libraries, or symbolic algebra libraries, or whatever they&rsquo;re marketing themselves as these days).
I was first introduced to PyTorch and TensorFlow and, having no other reference, thought they were prototypical examples of tensor computation libraries. Then I learnt about Theano &mdash; an older and less popular project, but different from PyTorch and TensorFlow and better in some meaningful ways. This was followed by JAX, which seemed to be basically NumPy with more bells and whistles (although I couldn&rsquo;t articulate what exactly they were)."><meta itemprop=name content="What I Wish Someone Had Told Me About Tensor Computation Libraries"><meta itemprop=description content="I get confused with tensor computation libraries (or computational graph libraries, or symbolic algebra libraries, or whatever they&rsquo;re marketing themselves as these days).
I was first introduced to PyTorch and TensorFlow and, having no other reference, thought they were prototypical examples of tensor computation libraries. Then I learnt about Theano &mdash; an older and less popular project, but different from PyTorch and TensorFlow and better in some meaningful ways. This was followed by JAX, which seemed to be basically NumPy with more bells and whistles (although I couldn&rsquo;t articulate what exactly they were)."><meta itemprop=datePublished content="2020-12-15T00:00:00+00:00"><meta itemprop=dateModified content="2020-12-15T00:00:00+00:00"><meta itemprop=wordCount content="2077"><meta itemprop=image content="https://www.georgeho.org/assets/images/asterism.png"><meta itemprop=keywords content="open-source,machine-learning,deep-learning,"><meta name=referrer content="no-referrer-when-downgrade"><style>body{font-family:Verdana,sans-serif;margin:auto;padding:20px;max-width:720px;text-align:left;background-color:#fff;word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:#444}h1,h2,h3,h4,h5,h6,strong,b{color:#222}a{color:#3273dc}.title{text-decoration:none;border:0}.title span{font-weight:400}nav a{margin-right:10px}textarea{width:100%;font-size:16px}input{font-size:16px}content{line-height:1.6}table{width:100%}img{max-width:100%}code{padding:2px 5px;background-color:#f2f2f2}pre code{color:#222;display:block;padding:20px;white-space:pre-wrap;font-size:14px}div.highlight pre{background-color:initial;color:initial}div.highlight code{background-color:unset;color:unset}blockquote{border-left:1px solid #999;color:#222;padding-left:20px;font-style:italic}footer{padding:25px;text-align:center}.helptext{color:#777;font-size:small}.errorlist{color:#eba613;font-size:small}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:#8b6fcb}@media(prefers-color-scheme:dark){body{background-color:#333;color:#ddd}h1,h2,h3,h4,h5,h6,strong,b{color:#eee}a{color:#8cc2dd}code{background-color:#777}pre code{color:#ddd}blockquote{color:#ccc}textarea,input{background-color:#252525;color:#ddd}.helptext{color:#aaa}}</style><script type=text/javascript src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({ tex2jax: {inlineMath: [["$", "$"]]} })
</script><script async src=//static.getclicky.com/101349618.js></script><noscript><p><img alt=Clicky width=1 height=1 src=//in.getclicky.com/101349618ns.gif></p></noscript><link rel=stylesheet media=all href=/assets/fonts/nicholson-gothic.css type=text/css><link rel=stylesheet media=all href=/assets/fonts/triplicate-a.css type=text/css><script type=text/javascript>navigator.appVersion.indexOf("Win")!=-1?document.write('<link rel="stylesheet" type="text/css" media="all" href="/assets/fonts/equity-a.css"/>'):navigator.appVersion.indexOf("Mac")!=-1?navigator.userAgent.match(/iPad/i)!=null?(document.write('<link rel="stylesheet" media="only screen and (max-device-width: 1024px)" href="/assets/fonts/equity-b.css" type="text/css"/>'),document.write('<link rel="stylesheet" media="only screen and (min-device-width: 768px) and (max-device-width: 1024px) and (-webkit-min-device-pixel-ratio: 2)" type="text/css" href="/assets/fonts/equity-a.css"/>')):document.write('<link rel="stylesheet" type="text/css" media="all" href="/assets/fonts/equity-b.css"/>'):document.write('<link rel="stylesheet" type="text/css" media="all" href="/assets/fonts/equity-a.css"/>')</script><style>html{font-size:18px;font-size:min(max(1rem,4vw),22px)}body{font-family:Equity,Georgia,serif;background-color:#fffff8}code{font-family:Triplicate,lucida console,monospace}pre code{white-space:pre;overflow-x:scroll;-webkit-overflow-scrolling:touch}h1,h2,h3,h4,h5,h6{font-family:NicholsonGothic,Verdana,sans-serif}@media(prefers-color-scheme:dark){body{background-color:#111}}</style></head><body><header><a href=/ class=title><h2>⁂ George Ho</h2></a><nav><a href=/>Home</a>
<a href=/work/>Work</a>
<a href=/blog>Blog</a></nav></header><main><h1>What I Wish Someone Had Told Me About Tensor Computation Libraries</h1><p><i><time datetime=2020-12-15 pubdate>2020-12-15</time></i></p><content><p>I get confused with tensor computation libraries (or computational graph libraries, or symbolic
algebra libraries, or whatever they&rsquo;re marketing themselves as these days).</p><p>I was first introduced to PyTorch and TensorFlow and, having no other reference, thought they were
prototypical examples of tensor computation libraries. Then I learnt about Theano &mdash; an older and
less popular project, but different from PyTorch and TensorFlow and better in some meaningful ways.
This was followed by JAX, which seemed to be basically NumPy with more bells and whistles (although
I couldn&rsquo;t articulate what exactly they were). Then came <a href=https://pymc-devs.medium.com/the-future-of-pymc3-or-theano-is-dead-long-live-theano-d8005f8a0e9b>the announcement by the PyMC developers
that Theano would have a new JAX
backend</a>.</p><p>Anyways, this confusion prompted a lot of research and eventually, this blog post.</p><p>Similar to <a href=https://www.georgeho.org/prob-prog-frameworks/>my previous post on the anatomy of probabilistic programming
frameworks</a>, I’ll first discuss tensor computation
libraries in general &mdash; what they are and how they can differ from one another. Then I&rsquo;ll discuss
some libraries in detail, and finally offer an observation on the future of Theano in the context of
contemporary tensor computation libraries.</p><div><h2>Contents</h2><nav id=TableOfContents><ul><li><a href=#dissecting-tensor-computation-libraries>Dissecting Tensor Computation Libraries</a><ul><li><a href=#tensor-computation-library-----maybe-not-the-best-name>&ldquo;Tensor Computation Library&rdquo; &mdash; Maybe Not The Best Name</a></li><li><a href=#some-differences-between-tensor-computation-libraries>(Some) Differences Between Tensor Computation Libraries</a></li></ul></li><li><a href=#a-zoo-of-tensor-computation-libraries>A Zoo of Tensor Computation Libraries</a><ul><li><a href=#pytorchhttpspytorchorg><a href=https://pytorch.org/>PyTorch</a></a></li><li><a href=#jaxhttpsjaxreadthedocsioenlatest><a href=https://jax.readthedocs.io/en/latest/>JAX</a></a></li><li><a href=#theanohttpstheano-pymcreadthedocsioenlatest><a href=https://theano-pymc.readthedocs.io/en/latest/>Theano</a></a></li></ul></li><li><a href=#an-observation-on-static-graphs-and-theano>An Observation on Static Graphs and Theano</a></li></ul></nav></div><h2 id=dissecting-tensor-computation-libraries>Dissecting Tensor Computation Libraries</h2><p>First, a characterization: what do tensor computation libraries even do?</p><ol><li>They provide ways of specifying and building computational graphs,</li><li>They run the computation itself (duh), but also run &ldquo;related&rdquo; computations that either (a) <em>use
the computational graph</em>, or (b) operate <em>directly on the computational graph itself</em>,<ul><li>The most salient example of the former is computing gradients via
<a href=https://arxiv.org/abs/1502.05767>autodifferentiation</a>,</li><li>A good example of the latter is optimizing the computation itself: think symbolic
simplifications (e.g. <code>xy/x = y</code>) or modifications for numerical stability (e.g. <a href=https://cs.stackexchange.com/q/68411><code>log(1 + x)</code>
for small values of <code>x</code></a>).</li></ul></li><li>And they provide &ldquo;best execution&rdquo; for the computation: whether it&rsquo;s changing the execution by JIT
(just-in-time) compiling it, by utilizing special hardware (GPUs/TPUs), by vectorizing the
computation, or in any other way.</li></ol><h3 id=tensor-computation-library-----maybe-not-the-best-name>&ldquo;Tensor Computation Library&rdquo; &mdash; Maybe Not The Best Name</h3><p>As an aside: I realize that the name &ldquo;tensor computation library&rdquo; is too broad, and that the
characterization above precludes some libraries that might also justifiably be called &ldquo;tensor
computation libraries&rdquo;. Better names might be &ldquo;graph computation library&rdquo; (although that might get
mixed up with libraries like <a href=https://networkx.org/><code>networkx</code></a>) or &ldquo;computational graph management
library&rdquo; or even &ldquo;symbolic tensor algebra libraries&rdquo;.</p><p>So for the avoidance of doubt, here is a list of libraries that this blog post is <em>not</em> about:</p><ul><li>NumPy and SciPy<ul><li>These libraries don&rsquo;t have a concept of a computational graph &mdash; they’re more like a toolbox of
functions, called from Python and executed in C or Fortran.</li><li>However, this might be a controversial distinction &mdash; as we’ll see later, JAX also doesn&rsquo;t build
an explicit computational graph either, and I definitely want to include JAX as a &ldquo;tensor
computation library&rdquo;&mldr; ¯\_(ツ)_/¯</li></ul></li><li>Numba and Cython<ul><li>These libraries provide best execution for code (and in fact some tensor computation libraries,
such as Theano, make good use them), but like NumPy and SciPy, they do not actually manage the
computational graph itself.</li></ul></li><li>Keras, Trax, Flax and PyTorch-Lightning<ul><li>These libraries are high-level wrappers around tensor computation libraries &mdash; they basically
provide abstractions and a user-facing API to utilize tensor computation libraries in a
friendlier way.</li></ul></li></ul><h3 id=some-differences-between-tensor-computation-libraries>(Some) Differences Between Tensor Computation Libraries</h3><p>Anyways, back to tensor computation libraries.</p><p>All three aforementioned goals are ambitious undertakings with sophisticated solutions, so it
shouldn&rsquo;t be surprising to learn that decisions in pursuit on goal can have implications for (or
even incur a trade-off with!) other goals. Here&rsquo;s a list of common differences along all three axes:</p><ol><li><p>Tensor computation libraries can differ in how they represent the computational graph, and how it
is built.</p><ul><li>Static or dynamic graphs: do we first define the graph completely and then inject data to run
(a.k.a. define-and-run), or is the graph defined on-the-fly via the actual forward computation
(a.k.a. define-by-run)?<ul><li>TensorFlow 1.x was (in)famous for its static graphs, which made users feel like they were
&ldquo;working with their computational graph through a keyhole&rdquo;, especially when <a href="https://news.ycombinator.com/item?id=13429355">compared to
PyTorch&rsquo;s dynamic graphs</a>.</li></ul></li><li>Lazy or eager execution: do we evaluate variables as soon as they are defined, or only when a
dependent variable is evaluated? Usually, tensor computation libraries either choose to support
dynamic graphs with eager execution, or static graphs with lazy execution &mdash; for example,
<a href=https://www.tensorflow.org/guide/eager>TensorFlow 2.0 supports both modes</a>.</li><li>Interestingly, some tensor computation libraries (e.g. <a href=https://thinc.ai/>Thinc</a>) don&rsquo;t even
construct an explicit computational graph: they represent it as <a href=https://thinc.ai/docs/concept>chained higher-order
functions</a>.</li></ul></li><li><p>Tensor computation libraries can also differ in what they want to use the computational graph
<em>for</em> &mdash; for example, are we aiming to do things that basically amount to running the
computational graph in a &ldquo;different mode&rdquo;, or are we aiming to modify the computational graph
itself?</p><ul><li>Almost all tensor computation libraries support autodifferentiation in some capacity (either
forward-mode, backward-mode, or both).</li><li>Obviously, how you represent the computational graph and what you want to use it for are very
related questions! For example, if you want to be able to represent aribtrary computation as a
graph, you&rsquo;ll have to handle control flow like if-else statements or for-loops &mdash; this leads
to common gotchas with <a href=https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#%F0%9F%94%AA-Control-Flow>using Python for-loops in
JAX</a>
or needing to use <a href=https://discuss.pytorch.org/t/can-you-have-for-loops-in-the-forward-prop/68295><code>torch.nn.ModuleList</code> in for-loops with
PyTorch</a>.</li><li>Some tensor computation libraries (e.g. <a href=https://github.com/Theano/Theano>Theano</a> and its
fork, <a href=https://theano-pymc.readthedocs.io/en/latest/index.html>Theano-PyMC</a>) aim to <a href=https://theano-pymc.readthedocs.io/en/latest/extending/optimization.html>optimize
the computational graph
itself</a>, for which an
<a href=#an-observation-on-static-graphs-and-theano>explicit graph is necessary</a>.</li></ul></li><li><p>Finally, tensor computation libraries can also differ in how they execute code.</p><ul><li>All tensor computation libraries run on CPU, but the strength of GPU and TPU support is a major
differentiator among tensor computation libraries.</li><li>Another differentiator is how tensor computation libraries compile code to be executed on
hardware. For example, do they use JIT compilation or not? Do they use &ldquo;vanilla&rdquo; C or CUDA
compilers, or <a href=https://tensorflow.google.cn/xla>the XLA compiler for machine-learning specific
code</a>?</li></ul></li></ol><h2 id=a-zoo-of-tensor-computation-libraries>A Zoo of Tensor Computation Libraries</h2><p>Having outlined the basic similarities and differences of tensor computation libraries, I think
it&rsquo;ll be helpful to go through several of the popular libraries as examples. I&rsquo;ve tried to link to
the relevant documentation where possible.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><h3 id=pytorchhttpspytorchorg><a href=https://pytorch.org/>PyTorch</a></h3><ol><li>How is the computational graph represented and built?<ul><li>PyTorch dynamically builds (and eagerly evaluates) an explicit computational graph. For more
detail on how this is done, check out <a href=https://pytorch.org/docs/stable/notes/autograd.html>the PyTorch docs on autograd
mechanics</a>.</li><li>For more on how PyTorch computational graphs, see <a href=https://jdhao.github.io/2017/11/12/pytorch-computation-graph/><code>jdhao</code>&rsquo;s introductory blog post on
computational graphs in
PyTorch</a>.</li></ul></li><li>What is the computational graph used for?<ul><li>To quote the <a href=https://pytorch.org/docs/stable/index.html>PyTorch docs</a>, &ldquo;PyTorch is an
optimized tensor library for deep learning using GPUs and CPUs&rdquo; &mdash; as such, the main focus is
on <a href=https://pytorch.org/docs/stable/notes/autograd.html>autodifferentiation</a>.</li></ul></li><li>How does the library ensure &ldquo;best execution&rdquo; for computation?<ul><li>PyTorch has <a href=https://pytorch.org/docs/stable/notes/cuda.html>native GPU support</a> via CUDA.</li><li>PyTorch also has support for TPU through projects like
<a href=https://github.com/pytorch/xla>PyTorch/XLA</a> and
<a href=https://www.pytorchlightning.ai/>PyTorch-Lightning</a>.</li></ul></li></ol><h3 id=jaxhttpsjaxreadthedocsioenlatest><a href=https://jax.readthedocs.io/en/latest/>JAX</a></h3><ol><li><p>How is the computational graph represented and built?</p><ul><li><p>Instead of building an explicit computational graph to compute gradients, JAX simply supplies a
<code>grad()</code> that returns the gradient function of any supplied function. As such, there is
technically no concept of a computational graph &mdash; only pure (i.e. stateless and
side-effect-free) functions and their gradients.</p></li><li><p><a href=https://sjmielke.com/jax-purify.htm>Sabrina Mielke summarizes the situation very well</a>:</p><blockquote><p>PyTorch builds up a graph as you compute the forward pass, and one call to <code>backward()</code> on
some &ldquo;result&rdquo; node then augments each intermediate node in the graph with the gradient of the
result node with respect to that intermediate node. JAX on the other hand makes you express
your computation as a Python function, and by transforming it with <code>grad()</code> gives you a
gradient function that you can evaluate like your computation function — but instead of the
output it gives you the gradient of the output with respect to (by default) the first
parameter that your function took as input.</p></blockquote></li></ul></li><li><p>What is the computational graph used for?</p><ul><li>According to the <a href=https://jax.readthedocs.io/en/latest/notebooks/quickstart.html>JAX quickstart</a>,
JAX bills itself as &ldquo;NumPy on the CPU, GPU, and TPU, with great automatic differentiation for
high-performance machine learning research&rdquo;. Hence, its focus is heavily on
autodifferentiation.</li></ul></li><li><p>How does the library ensure &ldquo;best execution&rdquo; for computation?</p><ul><li><p>This is best explained by quoting the <a href=https://jax.readthedocs.io/en/latest/notebooks/quickstart.html>JAX quickstart</a>:</p><blockquote><p>JAX uses XLA to compile and run your NumPy code on [&mldr;] GPUs and TPUs. Compilation happens
under the hood by default, with library calls getting just-in-time compiled and executed. But
JAX even lets you just-in-time compile your own Python functions into XLA-optimized kernels
[&mldr;] Compilation and automatic differentiation can be composed arbitrarily [&mldr;]</p></blockquote></li><li><p>For more detail on JAX’s four-function API (<code>grad</code>, <code>jit</code>, <code>vmap</code> and <code>pmap</code>), see
<a href=http://alexminnaar.com/2020/08/15/jax-overview.html>Alex Minaar&rsquo;s overview of how JAX works</a>.</p></li></ul></li></ol><h3 id=theanohttpstheano-pymcreadthedocsioenlatest><a href=https://theano-pymc.readthedocs.io/en/latest/>Theano</a></h3><blockquote><p><strong>Note:</strong> the <a href=https://github.com/Theano/Theano>original Theano</a> (maintained by
<a href=https://mila.quebec/en/>MILA</a>) has been discontinued, and the PyMC developers have forked the
project: <a href=https://github.com/pymc-devs/Theano-PyMC>Theano-PyMC</a> (soon to be renamed Aesara). I&rsquo;ll
discuss both the original and forked projects below.</p></blockquote><ol><li>How is the computational graph represented and built?<ul><li>Theano statically builds (and lazily evaluates) an explicit computational graph.</li></ul></li><li>What is the computational graph used for?<ul><li>Theano is unique among tensor computation libraries in that it places more emphasis on
reasoning about the computational graph itself. In other words, while Theano has <a href=https://theano-pymc.readthedocs.io/en/latest/library/gradient.html>strong
support for
autodifferentiation</a>,
running the computation and computing gradients isn&rsquo;t the be-all and end-all: Theano has an
entire module for <a href=https://theano-pymc.readthedocs.io/en/latest/optimizations.html>optimizing the computational graph
itself</a>, and makes it fairly
straightforward to compile the Theano graph to different computational backends (by default,
Theano compiles to C or CUDA, but it’s straightforward to compile to JAX).</li><li>Theano is often remembered as a library for deep learning research, but it’s so much more than
that!</li></ul></li><li>How does the library ensure &ldquo;best execution&rdquo; for computation?<ul><li>The original Theano used the GCC C compiler for CPU computation, and the NVCC CUDA compiler for
GPU computation.</li><li>The Theano-PyMC fork project <a href=https://pymc-devs.medium.com/the-future-of-pymc3-or-theano-is-dead-long-live-theano-d8005f8a0e9b>will use JAX as a
backend</a>,
which can utilize CPUs, GPUs and TPUs as available.</li></ul></li></ol><h2 id=an-observation-on-static-graphs-and-theano>An Observation on Static Graphs and Theano</h2><p>Finally, a quick observation on static graphs and the niche that Theano fills that other tensor
computation libraries do not. I had huge help from <a href=https://twiecki.io/>Thomas Wiecki</a> and
<a href=https://brandonwillard.github.io/>Brandon Willard</a> with this section.</p><p>There&rsquo;s been a consistent movement in most tensor computation libraries away from static graphs (or
more precisely, statically <em>built</em> graphs): PyTorch and TensorFlow 2 both support dynamically
generated graphs by default, and JAX forgoes an explicit computational graph entirely.</p><p>This movement is understandable &mdash; building the computational graph dynamically matches people&rsquo;s
programming intuition much better. When I write <code>z = x + y</code>, I don&rsquo;t mean <em>&ldquo;I want to register a sum
operation with two inputs, which is waiting for data to be injected&rdquo;</em> &mdash; I mean <em>&ldquo;I want to compute
the sum of <code>x</code> and <code>y</code>&rdquo;.</em> The extra layer of indirection is not helpful to most users, who just want
to run their tensor computation at some reasonable speed.</p><p>So let me speak in defence of statically built graphs.</p><p>Having an explicit representation of the computational graph is immensely useful for certain things,
even if it makes the graph harder to work with. You can modify the graph (e.g. graph optimizations,
simplifications and rewriting), and you can reason about and analyze the graph. Having the
computation as an actual <em>object</em> helps immeasurably for tasks where you need to think about the
computation itself, instead of just blindly running it.</p><p>On the other hand, with dynamically generated graphs, the computational graph is never actually
defined anywhere: the computation is traced out on the fly and behind the scene. You can no longer
do anything interesting with the computational graph: for example, if the computation is slow, you
can&rsquo;t reason about <em>what</em> parts of the graph are slow. The end result is that you basically have to
hope that the framework internals are doing the right things, which they might not!</p><p>This is the niche that Theano (or rather, Theano-PyMC/Aesara) fills that other contemporary tensor
computation libraries do not: the promise is that if you take the time to specify your computation
up front and all at once, Theano can optimize the living daylight out of your computation &mdash; whether
by graph manipulation, efficient compilation or something else entirely &mdash; and that this is something
you would only need to do once.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Some readers will notice the conspicuous lack of TensorFlow from this list - its exclusion isn&rsquo;t out of malice, merely a lack of time and effort to do the necessary research to do it justice. Sorry.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></content><p><a href=https://www.georgeho.org/blog/open-source/>#open-source</a>
<a href=https://www.georgeho.org/blog/machine-learning/>#machine-learning</a>
<a href=https://www.georgeho.org/blog/deep-learning/>#deep-learning</a></p></main><footer>Made with <a href=https://github.com/janraasch/hugo-bearblog/>Hugo ʕ•ᴥ•ʔ Bear</a></footer></body></html>